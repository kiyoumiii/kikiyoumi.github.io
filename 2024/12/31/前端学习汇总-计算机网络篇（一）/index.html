<!-- build time:Tue Dec 31 2024 14:10:33 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hexo" href="https://kiyoumiii.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hexo" href="https://kiyoumiii.github.io/atom.xml"><link rel="alternate" type="application/json" title="Hexo" href="https://kiyoumiii.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="前端"><link rel="canonical" href="https://kiyoumiii.github.io/2024/12/31/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"><title>前端学习汇总-计算机网络篇（一） - 计算机科学 | Yume Shoka = Hexo</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">前端学习汇总-计算机网络篇（一）</h1><div class="meta"><span class="item" title="创建时间：2024-12-31 14:06:28"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-12-31T14:06:28+08:00">2024-12-31</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2024/12/27/Ix1ftLwTzOsNdU5.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/12/27/Z2uYAzEt9BThdF3.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/12/27/YtXRN3FozvqPnUD.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/12/27/ErlmUOSZGs1ypY4.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/12/27/LjZWYulnxfRm1pV.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/12/27/hYJunlxKyrf5HRE.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kiyoumiii.github.io/2024/12/31/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="kiyoumiii"><meta itemprop="description" content=", kiyoumiii's blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><div class="body md" itemprop="articleBody"><h2 id="计算机网络知识总结篇httphttps"><a class="anchor" href="#计算机网络知识总结篇httphttps">#</a> 计算机网络知识总结篇：HTTP，HTTPS</h2><h3 id="一-http协议"><a class="anchor" href="#一-http协议">#</a> 一、HTTP 协议</h3><h4 id="1-get和post的请求的区别"><a class="anchor" href="#1-get和post的请求的区别">#</a> 1. GET 和 POST 的请求的区别</h4><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p><ul><li>应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li><li>是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li><li>发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li><li>安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li><li>请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li><li>参数类型： post 的参数传递支持更多的数据类型。</li></ul><h4 id="2-post和put请求的区别"><a class="anchor" href="#2-post和put请求的区别">#</a> 2. POST 和 PUT 请求的区别</h4><ul><li>PUT 请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次 PUT 操作，其结果并没有不同。（可以理解为是<strong>更新数据</strong>）</li><li>POST 请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li></ul><h4 id="3常见的http请求头和响应头"><a class="anchor" href="#3常见的http请求头和响应头">#</a> 3. 常见的 HTTP 请求头和响应头</h4><p>HTTP Request Header 常见的请求头：</p><ul><li>Accept: 浏览器能够处理的内容类型</li><li>Accept-Charset: 浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何 Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的 URL</li><li>User-Agent：浏览器的用户代理字符串</li></ul><p>HTTP Responses Header 常见的响应头：</p><ul><li>Date：表示消息发送的时间，时间的描述格式由 rfc822 定义</li><li>server: 服务器名称</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cache-Control：控制 HTTP 缓存</li><li>content-type: 表示后面的文档属于什么 MIME 类型</li></ul><p>常见的 Content-Type 属性值有以下四种：<br>（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。<br>（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。<br>（3）application/json：服务器消息主体是序列化后的 JSON 字符串。<br>（4）text/xml：该种方式主要用来提交 XML 格式的数据。</p><h4 id="4http状态码304是多好还是少好"><a class="anchor" href="#4http状态码304是多好还是少好">#</a> 4.HTTP 状态码 304 是多好还是少好</h4><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回 304，此时客户端调用缓存内容，不必进行二次下载。</p><p>状态码 304 不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。</p><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于 304 的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p><p>产生较多 304 状态码的原因：</p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态 html</li></ul><p>304 状态码出现过多会造成以下问题：</p><ul><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。</li></ul><h4 id="5-常见的http请求方法"><a class="anchor" href="#5-常见的http请求方法">#</a> 5. 常见的 HTTP 请求方法</h4><ul><li>GET: 向服务器获取数据；</li><li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li><li>PUT：上传文件，更新数据；</li><li>DELETE：删除服务器上的对象；</li><li>HEAD：获取报文首部，与 GET 相比，不返回报文主体部分；</li><li>OPTIONS：询问支持的请求方法，用来跨域请求；</li><li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行 TCP 通信；</li><li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li></ul><h4 id="6-options请求方法及使用场景"><a class="anchor" href="#6-options请求方法及使用场景">#</a> 6. OPTIONS 请求方法及使用场景</h4><p>OPTIONS 是除了 GET 和 POST 之外的其中一种 HTTP 请求方法。</p><p>OPTIONS 方法是用于请求获得由 Request-URI 标识的资源在请求 / 响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。</p><p>OPTIONS 请求方法的主要用途有两个：</p><ul><li>获取服务器支持的所有 HTTP 请求方法；</li><li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li></ul><h4 id="7-http-10-和-http-11-之间有哪些区别"><a class="anchor" href="#7-http-10-和-http-11-之间有哪些区别">#</a> 7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h4><p>HTTP 1.0 和 HTTP 1.1 有以下区别：</p><ul><li>连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li>资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li>缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li>http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li>http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。</li></ul><h4 id="8-http-11-和-http-20-的区别"><a class="anchor" href="#8-http-11-和-http-20-的区别">#</a> 8. HTTP 1.1 和 HTTP 2.0 的区别</h4><ul><li>二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为 &quot;帧&quot;，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li><li>多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了 &quot;队头堵塞&quot;【1】的问题。</li><li>数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li><li>头信息压缩：HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li><li>服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主要推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><p>P.S. 队头堵塞：<br>队头堵塞是由 HTTP 基本的 “请求 - 应答” 模型所导致的。HTTP 规定报文必须是 “一发一收”，这就形成了一个先进先出的 “串行” 队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p><h4 id="9-http和https协议的区别"><a class="anchor" href="#9-http和https协议的区别">#</a> 9. HTTP 和 HTTPS 协议的区别</h4><p>HTTP 和 HTTPS 协议的主要区别如下：</p><ul><li>HTTPS 协议需要 CA 证书，费用较高；而 HTTP 协议不需要；</li><li>HTTP 协议是超文本传输协议，信息是明文传输的，HTTPS 则是具有安全性的 SSL 加密传输协议；</li><li>使用不同的连接方式，端口也不同，HTTP 协议端口是 80，HTTPS 协议端口是 443；</li><li>HTTP 协议连接很简单，是无状态的；HTTPS 协议是有 SSL 和 HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 更加安全。</li></ul><h4 id="10-get方法url长度限制的原因"><a class="anchor" href="#10-get方法url长度限制的原因">#</a> 10. GET 方法 URL 长度限制的原因</h4><p>实际上 HTTP 协议规范并没有对 get 方法请求的 url 长度进行限制，这个限制是特定的浏览器及服务器对它的限制。<br>IE 对 URL 长度的限制是 2083 字节 (2K+35)。由于 IE 浏览器对 URL 长度的允许值是最小的，所以开发过程中，只要 URL 不超过 2083 字节，那么在所有浏览器中工作都不会有问题。</p><figure class="highlight javascript"><figcaption data-lang="javascript"><span>t</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token constant">GET</span>的长度值 <span class="token operator">=</span> <span class="token constant">URL</span>（<span class="token number">2083</span>）<span class="token operator">-</span> （你的Domain<span class="token operator">+</span>Path）<span class="token operator">-</span><span class="token number">2</span>（<span class="token number">2</span>是<span class="token keyword">get</span>请求中<span class="token operator">?</span><span class="token operator">=</span>两个字符的长度）</pre></td></tr></table></figure><p>下面看一下主流浏览器对 get 方法中 url 的长度限制范围：</p><ul><li>Microsoft Internet Explorer (Browser)：IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应。</li><li>Firefox (Browser)：对于 Firefox 浏览器 URL 的长度限制为 65,536 个字符。</li><li>Safari (Browser)：URL 最大长度限制为 80,000 个字符。</li><li>Opera (Browser)：URL 最大长度限制为 190,000 个字符。</li><li>Google (chrome)：URL 最大长度限制为 8182 个字符。</li></ul><p>主流的服务器对 get 方法中 url 的长度限制范围：</p><ul><li>Apache (Server)：能接受最大 url 长度为 8192 个字符。</li><li>Microsoft Internet Information Server (IIS)：能接受最大 url 的长度为 16384 个字符。</li></ul><p>根据上面的数据，可以知道，get 方法中的 URL 长度最长不超过 2083 个字符，这样所有的浏览器和服务器都可能正常工作。</p><h4 id="11-当在浏览器中输入-googlecom-并且按下回车之后发生了什么"><a class="anchor" href="#11-当在浏览器中输入-googlecom-并且按下回车之后发生了什么">#</a> 11. 当在浏览器中输入 <span class="exturl" data-url="aHR0cDovL0dvb2dsZS5jb20=">Google.com</span> 并且按下回车之后发生了什么？</h4><p>（1）解析 URL： 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p><p>（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p><p>（3）DNS 解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p><p>（4）获取 MAC 地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p><p>（5）TCP 三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p><p>（6）HTTPS 握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p><p>（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p><p>（8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p><p>（9）TCP 四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p><h4 id="12-对keep-alive的理解"><a class="anchor" href="#12-对keep-alive的理解">#</a> 12. 对 keep-alive 的理解</h4><p>HTTP1.0 中默认是在每次请求 / 应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。<br>当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接，这就是长连接。其使用方法如下：</p><ul><li>HTTP1.0 版本是默认没有 Keep-alive 的（也就是默认会发送 keep-alive），所以要想连接得到保持，必须手动配置发送 Connection: keep-alive 字段。若想断开 keep-alive 连接，需发送 Connection:close 字段；</li><li>HTTP1.1 规定了默认保持长连接，数据传输完成了保持 TCP 连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送 Connection：close 首部字段。</li></ul><p>Keep-Alive 的建立过程：</p><ul><li>客户端向服务器在发送请求报文同时在首部添加发送 Connection 字段</li><li>服务器收到请求并处理 Connection 字段</li><li>服务器回送 Connection:Keep-Alive 字段给客户端</li><li>客户端接收到 Connection 字段</li><li>Keep-Alive 连接建立成功</li></ul><p>服务端自动断开过程（也就是没有 keep-alive）：</p><ul><li>客户端向服务器只是发送内容报文（不包含 Connection 字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有 Connection 字段，断开连接</li></ul><p>客户端请求断开连接过程：</p><ul><li>客户端向服务器发送 Connection:close 字段</li><li>服务器收到请求并处理 connection 字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接</li></ul><p>开启 Keep-Alive 的优点：</p><ul><li>较少的 CPU 和内存的使⽤（由于同时打开的连接的减少了）；</li><li>允许请求和应答的 HTTP 管线化；</li><li>降低拥塞控制 （TCP 连接减少了）；</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li><li>报告错误⽆需关闭 TCP 连接；</li></ul><p>开启 Keep-Alive 的缺点：<br>长时间的 Tcp 连接容易导致系统资源无效占用，浪费系统资源。</p><h4 id="13-页面有多张图片http是怎样的加载表现"><a class="anchor" href="#13-页面有多张图片http是怎样的加载表现">#</a> 13. 页面有多张图片，HTTP 是怎样的加载表现？</h4><ul><li>在 HTTP 1 下，浏览器对一个域名下最大 TCP 连接数为 6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li><li>在 HTTP 2 下，可以一瞬间加载出来很多资源，因为，HTTP2 支持多路复用，可以在一个 TCP 连接中发送多个 HTTP 请求。</li></ul><h4 id="14-http2的头部压缩算法是怎样的"><a class="anchor" href="#14-http2的头部压缩算法是怎样的">#</a> 14. HTTP2 的头部压缩算法是怎样的？</h4><p>HTTP2 的头部压缩是 HPACK 算法。在客户端和服务器两端建立 “字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。</p><p>具体来说:</p><ul><li>在客户端和服务器端使用 “首部表” 来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li><li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><p>如有两个请求， 请求二只是和请求一的:path 字段不同，其他都相同，请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p><h4 id="15-http请求报文是什么样的"><a class="anchor" href="#15-http请求报文是什么样的">#</a> 15. HTTP 请求报文是什么样的？</h4><p>请求报⽂有 4 部分组成:</p><ul><li>请求⾏</li><li>请求头部</li><li>空⾏</li><li>请求体</li></ul><p>其中：<br>（1）请求⾏包括：请求⽅法字段、URL 字段、HTTP 协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。<br>（2）请求头部：请求头部由关键字 / 值对组成，每⾏⼀对，关键字和值⽤英⽂冒号 “:” 分隔</p><ul><li>User-Agent：产⽣请求的浏览器类型。</li><li>Accept：客户端可识别的内容类型列表。</li><li>Host：请求的主机名，允许多个域名同处⼀个 IP 地址，即虚拟主机。</li></ul><p>（3）请求体: post put 等请求携带的数据</p><h4 id="16-http响应报文是什么样的"><a class="anchor" href="#16-http响应报文是什么样的">#</a> 16. HTTP 响应报文是什么样的？</h4><p>响应报⽂有 4 部分组成:</p><ul><li>响应⾏</li><li>响应头部</li><li>空⾏</li><li>响应体</li></ul><p>其中：</p><ul><li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。</li><li>响应头部：响应部⾸组成</li><li>响应体：服务器响应的数据</li></ul><h4 id="17-http协议的优点和缺点"><a class="anchor" href="#17-http协议的优点和缺点">#</a> 17. HTTP 协议的优点和缺点</h4><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p><p>HTTP 协议具有以下优点：</p><ul><li>支持客户端 / 服务器模式</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li>无连接：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li><li>无状态：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li><li>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li></ul><p>HTTP 协议具有以下缺点：</p><ul><li>无状态： HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li><li>明文传输： 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li><li>不安全</li></ul><p>（1）通信使用明文（不加密），内容可能会被窃听；<br>（2）不验证通信方的身份，因此有可能遭遇伪装；<br>（3）无法证明报文的完整性，所以有可能已遭篡改；</p><h4 id="18-说一下http-30"><a class="anchor" href="#18-说一下http-30">#</a> 18. 说一下 HTTP 3.0</h4><p>HTTP/3 基于 UDP 协议实现了类似于 TCP 的多路复用数据流、传输可靠性等功能，这套功能被称为 QUIC 协议。<br>1. 流量控制、传输可靠性功能：QUIC 在 UDP 的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些 TCP 中的特性。<br>2. 集成 TLS 加密功能：目前 QUIC 使用 TLS1.3，减少了握手所花费的 RTT 数。<br>3. 多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了 TCP 的队头阻塞问题。<br>4. 快速握手：由于基于 UDP，可以实现使用 0 ~ 1 个 RTT 来建立连接。</p><h4 id="19-http协议的性能怎么样"><a class="anchor" href="#19-http协议的性能怎么样">#</a> 19. HTTP 协议的性能怎么样</h4><p>HTTP 协议是基于 TCP/IP，并且使用了请求 - 应答的通信模式，所以性能的关键就在这两点里。</p><ul><li>长连接<br>HTTP 协议有两种连接模式，一种是持续连接，一种非持续连接。<br>（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。<br>（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</li></ul><p>对于不同版本的采用不同的连接方式：</p><ul><li>在 HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</li><li>在 HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</li><li>管道网络传输<br>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。<br>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</li></ul><div align="center"><style></style><img data-src="/2024/12/31/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/http1%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5.jpg" class="fuyufqfnchsc"></div><ul><li>队头堵塞<br>HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是 HTTP 队头阻塞问题。</li></ul><p>队头阻塞的解决方案：<br>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。<br>（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p><h4 id="20-url有哪些组成部分"><a class="anchor" href="#20-url有哪些组成部分">#</a> 20. URL 有哪些组成部分</h4><p>以下面的 URL 为例：<span class="exturl" data-url="aHR0cDovL3d3dy5hc3B4ZmFucy5jb206ODA4MC9uZXdzL2luZGV4LmFzcD9ib2FyZElEPTUmYW1wO0lEPTI0NjE4JmFtcDtwYWdlPTEjbmFtZQ==">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</span></p><p>从上面的 URL 可以看出，一个完整的 URL 包括以下几部分：</p><ul><li>协议部分：该 URL 的协议部分为 “http：”，这代表网页使用的是 HTTP 协议。在 Internet 中可以使用多种协议，如 HTTP，FTP 等等本例中使用的是 HTTP 协议。在 &quot;HTTP&quot; 后面的 “//” 为分隔符；</li><li>域名部分：该 URL 的域名部分为 “<span class="exturl" data-url="aHR0cDovL3d3dy5hc3B4ZmFucy5jb20=">www.aspxfans.com</span>”。一个 URL 中，也可以使用 IP 地址作为域名使用.</li><li>端口部分：跟在域名后面的是端口，域名和端口之间使用 “:” 作为分隔符。端口不是一个 URL 必须的部分，如果省略端口部分，将采用默认端口（HTTP 协议默认端口是 80，HTTPS 协议默认端口是 443）；</li><li>虚拟目录部分：从域名后的第一个 “/” 开始到最后一个 “/” 为止，是虚拟目录部分。虚拟目录也不是一个 URL 必须的部分。本例中的虚拟目录是 “/news/”；</li><li>文件名部分：从域名后的最后一个 “/” 开始到 “？” 为止，是文件名部分，如果没有 “?”, 则是从域名后的最后一个 “/” 开始到 “#” 为止，是文件部分，如果没有 “？” 和 “#”，那么从域名后的最后一个 “/” 开始到结束，都是文件名部分。</li><li>锚部分：从 “#” 开始到最后，都是锚部分。本例中的锚部分是 “name”。锚部分也不是一个 URL 必须的部分；</li><li>参数部分：从 “？” 开始到 “#” 为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为 “boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用 “&amp;” 作为分隔符。</li></ul><h4 id="21-与缓存相关的http请求头有哪些"><a class="anchor" href="#21-与缓存相关的http请求头有哪些">#</a> 21. 与缓存相关的 HTTP 请求头有哪些</h4><p>强缓存：</p><ul><li>Expires</li><li>Cache-Control</li></ul><p>协商缓存：</p><ul><li>Etag、If-None-Match</li><li>Last-Modified、If-Modified-Since</li></ul><div class="tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="ic i-tag"></i> 前端</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-12-31 14:10:14" itemprop="dateModified" datetime="2024-12-31T14:10:14+08:00">2024-12-31</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="kiyoumiii 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="kiyoumiii 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="kiyoumiii 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>kiyoumiii <i class="ic i-at"><em>@</em></i>Hexo</li><li class="link"><strong>本文链接：</strong> <a href="https://kiyoumiii.github.io/2024/12/31/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端学习汇总-计算机网络篇（一）">https://kiyoumiii.github.io/2024/12/31/前端学习汇总-计算机网络篇（一）/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/12/28/%E8%87%AA%E7%94%A8%E5%B8%B8%E5%A4%87linux%E5%91%BD%E4%BB%A4/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2024&#x2F;12&#x2F;27&#x2F;YtXRN3FozvqPnUD.jpg" title="自用常备linux命令"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机科学</span><h3>自用常备linux命令</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%AF%87httphttps"><span class="toc-number">1.</span> <span class="toc-text">计算机网络知识总结篇：HTTP，HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-http%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.</span> <span class="toc-text">一、HTTP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-get%E5%92%8Cpost%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. GET 和 POST 的请求的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-post%E5%92%8Cput%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. POST 和 PUT 请求的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%B8%B8%E8%A7%81%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 常见的 HTTP 请求头和响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4http%E7%8A%B6%E6%80%81%E7%A0%81304%E6%98%AF%E5%A4%9A%E5%A5%BD%E8%BF%98%E6%98%AF%E5%B0%91%E5%A5%BD"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.HTTP 状态码 304 是多好还是少好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B8%B8%E8%A7%81%E7%9A%84http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 常见的 HTTP 请求方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-options%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. OPTIONS 请求方法及使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-http-10-%E5%92%8C-http-11-%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.7.</span> <span class="toc-text">7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-http-11-%E5%92%8C-http-20-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.8.</span> <span class="toc-text">8. HTTP 1.1 和 HTTP 2.0 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.9.</span> <span class="toc-text">9. HTTP 和 HTTPS 协议的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-get%E6%96%B9%E6%B3%95url%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.1.10.</span> <span class="toc-text">10. GET 方法 URL 长度限制的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-googlecom-%E5%B9%B6%E4%B8%94%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.11.</span> <span class="toc-text">11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.12.</span> <span class="toc-text">12. 对 keep-alive 的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87http%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%A1%A8%E7%8E%B0"><span class="toc-number">1.1.13.</span> <span class="toc-text">13. 页面有多张图片，HTTP 是怎样的加载表现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-http2%E7%9A%84%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">1.1.14.</span> <span class="toc-text">14. HTTP2 的头部压缩算法是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">1.1.15.</span> <span class="toc-text">15. HTTP 请求报文是什么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">1.1.16.</span> <span class="toc-text">16. HTTP 响应报文是什么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.17.</span> <span class="toc-text">17. HTTP 协议的优点和缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E8%AF%B4%E4%B8%80%E4%B8%8Bhttp-30"><span class="toc-number">1.1.18.</span> <span class="toc-text">18. 说一下 HTTP 3.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%A7%E8%83%BD%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">1.1.19.</span> <span class="toc-text">19. HTTP 协议的性能怎么样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-url%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.1.20.</span> <span class="toc-text">20. URL 有哪些组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E4%B8%8E%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.21.</span> <span class="toc-text">21. 与缓存相关的 HTTP 请求头有哪些</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/07/25/%E6%98%87%E8%85%BECANN-Ascend-C%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="bookmark" title="昇腾CANN-Ascend C算子开发学习笔记">昇腾CANN-Ascend C算子开发学习笔记</a></li><li><a href="/2024/07/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="bookmark" title="前端基础--HTTP基本概念">前端基础--HTTP基本概念</a></li><li><a href="/2024/07/31/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/" rel="bookmark" title="前端基础--浏览器是如何运作的">前端基础--浏览器是如何运作的</a></li><li><a href="/2024/08/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" rel="bookmark" title="计算机网络-基础知识笔记（一）">计算机网络-基础知识笔记（一）</a></li><li><a href="/2024/08/12/HTTP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" rel="bookmark" title="HTTP协议相关知识">HTTP协议相关知识</a></li><li><a href="/2024/12/28/%E7%AE%80%E5%8D%95%E6%9C%89%E6%95%88%E7%9A%84%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" rel="bookmark" title="简单有效的密钥配置教程">简单有效的密钥配置教程</a></li><li><a href="/2024/12/28/%E8%B6%85%E7%BA%A7%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9Bgit%E5%91%BD%E4%BB%A4/" rel="bookmark" title="超级常用的一些git命令">超级常用的一些git命令</a></li><li><a href="/2024/12/28/%E8%87%AA%E7%94%A8%E5%B8%B8%E5%A4%87linux%E5%91%BD%E4%BB%A4/" rel="bookmark" title="自用常备linux命令">自用常备linux命令</a></li><li class="active"><a href="/2024/12/31/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/" rel="bookmark" title="前端学习汇总-计算机网络篇（一）">前端学习汇总-计算机网络篇（一）</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="kiyoumiii" data-src="/images/avatar.jpg"><p class="name" itemprop="name">kiyoumiii</p><div class="description" itemprop="description">kiyoumiii's blog</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">23</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpeW91bWlpaQ==" title="https:&#x2F;&#x2F;github.com&#x2F;kiyoumiii"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/front-end/" title="分类于 前端开发">前端开发</a></div><span><a href="/2024/08/17/%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" title="前端编程语言">前端编程语言</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/2024/12/28/%E8%B6%85%E7%BA%A7%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9Bgit%E5%91%BD%E4%BB%A4/" title="超级常用的一些git命令">超级常用的一些git命令</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/front-end/" title="分类于 前端开发">前端开发</a></div><span><a href="/2024/07/22/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E7%BF%BB%E9%A1%B5%E6%BC%AB%E7%94%BB%E4%B9%A6/" title="前端学习记录--翻页漫画书">前端学习记录--翻页漫画书</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/2024/07/31/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/" title="前端基础--浏览器是如何运作的">前端基础--浏览器是如何运作的</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/front-end/" title="分类于 前端开发">前端开发</a></div><span><a href="/2024/07/22/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%97%B6%E9%97%B4%E8%BD%B4%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/" title="前端学习记录--时间轴效果实现">前端学习记录--时间轴效果实现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/front-end/" title="分类于 前端开发">前端开发</a></div><span><a href="/2024/09/17/SEO%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/" title="SEO优化策略总结">SEO优化策略总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/2024/08/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="计算机网络-基础知识笔记（一）">计算机网络-基础知识笔记（一）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/2024/07/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="前端基础--HTTP基本概念">前端基础--HTTP基本概念</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/deep-learning/" title="分类于 深度学习">深度学习</a></div><span><a href="/2024/07/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/" title="大模型基础">大模型基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/2024/12/28/%E8%87%AA%E7%94%A8%E5%B8%B8%E5%A4%87linux%E5%91%BD%E4%BB%A4/" title="自用常备linux命令">自用常备linux命令</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">kiyoumiii @ Yume Shoka</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">88k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:20</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/12/31/前端学习汇总-计算机网络篇（一）/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->